namespace sharing

import common
import files

struct ExpectedSharedFolderMetadata extends SharedFolderMetadataBase
    "Properties the shared folder will have upon creation."

    link_metadata ExpectedSharedContentLinkMetadata?
        "The link metadata for this shared folder."
    policy FolderPolicy
        "Policies governing this shared folder."
    permissions List(InternalFolderPermission)?
        "Actions the current user may perform on the folder and its contents.
        The set of permissions corresponds to the :type:InternalFolderActions in the request."
    members_cursor String?
        "Cursor to retrieve inherited members of this shared folder,
        if any exist. Pass into :route:`list_folder_members/continue`
        to list members. This field is present only if
        :field:`ValidateFolderPathArg.list_members_arg`
        was specified."

    example default
        path_lower = "/dir"
        access_type = owner
        is_inside_team_folder = false
        is_team_folder = false
        link_metadata = default
        policy = default
        permissions = []
        members_cursor = "ZtkX9_EHj3x7PMkVuFIhwKYXEpwpLwyxp9vMKomUhllil9q7eWiAu"

union ValidateFolderPathError extends ShareFolderErrorBase
    no_permission ExpectedSharedFolderMetadata?
        "The current user does not have permission to perform this action. If they don't have
        permission because it would create a nested shared folder, this contains metadata about
        the shared folder that would be created at this path if the user had the permissions to
        share it."
    no_access
        "The current user don't have access to sharing related information of this path. This can
        happen when the user is not in the membership of the containing shared folder of this path."

route validate_folder_path(ValidateFolderPathArg, ExpectedSharedFolderMetadata, ValidateFolderPathError)
    "Determine whether a shared folder can be created at a given path.
    If so, returns metadata for the yet-to-be-created shared folder.
    If not, the error explains why not.

    Apps must have full Dropbox access to use this endpoint.

    Warning: Do not make backwards-incompatible changes to this endpoint without talking to mobile
    - currently many mobile clients are using this endpoint"

    attrs
        owner = "sfi"

struct ValidateFolderPathArg
    path files.WritePath
        "Folder path to validate for shared folder creation."
    actions List(InternalFolderAction)?
        "Folder actions to query."
    list_members_arg ListFolderMembersCursorArg?
        "If this field is provided, the return value will include a cursor
        for listing inherited folder members."

    example default
        path = "/example/workspace"
        actions = []
        list_members_arg = default

# --

route validate_folder_path/batch(ValidateFolderPathBatchArg, ValidateFolderPathBatchResult, ValidateFolderPathError)
    "Determines whether a shared folder can be created at each of the given paths.
    For each path, we return either metadata for the yet-to-be-shared folder at that path
    or an error explaining why a shared folder cannot be created at that path."

    attrs
        owner = "sfi"

struct ValidateFolderPathBatchArg
    paths List(files.WritePath)
        "Folder paths to validate for shared folder creation."
    actions List(InternalFolderAction)?
        "Folder actions to query."
    list_members_arg ListFolderMembersCursorArg?
        "If this field is provided, the return value will include a cursor
        for listing inherited folder members."

    example default
        paths = ["/example/workspace", "/example/other"]
        actions = []
        list_members_arg = default

struct ValidateFolderPathBatchResult
    entries List(ValidateFolderPathBatchEntry)

struct ValidateFolderPathBatchEntry
    path files.Path?
        "Input path corresponding to one of :field:`ValidateFolderPathBatchArg.paths`.
        Absent for unmounted folders."
    result ValidateFolderPathIndividualResult
        "Result of the given path."

    example default
        path = "/example/workspace"
        result = default

union ValidateFolderPathIndividualResult
    metadata ExpectedSharedFolderMetadata
        "Metadata for the yet-to-be-shared folder if a shared folder can be created at this path."
    path_error ValidateFolderPathError
        "Error explaining why a shared folder cannot be created at this path."

    example default
        metadata = default

# --

struct MemberCounts
    "Shared folder user counts."

    total_unique_users UInt32
        "Total number of unique users."
    users_outside_team UInt32?
        "Number of unique users outside the team. This field is only present if the folder
        is owned by a team to which the calling user belongs."

    example default
        total_unique_users = 3
        users_outside_team = 1

route get_folder_member_counts(GetFolderMemberCountsArgs, MemberCounts, SharedFolderAccessError)
    "Returns shared folder membership counts for the folder ID.

    Apps must have full Dropbox access to use this endpoint."

    attrs
        owner = "sfi"

struct GetFolderMemberCountsArgs
    shared_folder_id common.SharedFolderId
        "The ID for the shared folder."

    example default
        shared_folder_id = "84528192421"

# --

route list_all_members(SharedFolderListMembersArg, SharedFolderTreeMembers, SharedFolderAccessError)
    "Returns all users in a shared folder recursively, as well as the access level for each user.
    The access levels represent the max level the user has at any point in the shared folder."

    attrs
        owner = "company-dropbox-team"

struct SharedFolderListMembersArg
    shared_folder_id common.SharedFolderId
        "The ID for the shared folder."
    path files.Path?
        "Path to the folder to be searched, relative to the shared folder.
        If the empty string or no path is provided, then the entire shared folder tree is searched."

    example default
        shared_folder_id = "84528192421"
        path = "/Folder"

struct GroupToUsers
    group_id String
    user_ids List(String)?
        "List of user ids for the specified group. No list is present if the API caller
        does not have privileges to view group members."

    example default
        group_id = ""
        user_ids = [""]

struct SharedFolderTreeUser
    user_info UserMembershipInfo
    access_point SharedFolderTreeAccessPoint

    example default
        user_info = default
        access_point = first_access

struct SharedFolderTreeGroup
    group_info GroupMembershipInfo
    access_point SharedFolderTreeAccessPoint

    example default
        group_info = default
        access_point = first_access

struct SharedFolderTreeMembers
    users List(SharedFolderTreeUser)
    groups List(SharedFolderTreeGroup)
    group_to_users List(GroupToUsers)

    example default
        users = [default]
        groups = [default]
        group_to_users = [default]

union SharedFolderTreeAccessPoint
    inherited_access
        "Member has access to the tree via access inherited from a parent shared folder."
    first_access
        "Member has access to the tree starting from the requested shared folder."
    nested_access
        "Member does not have access to the requested shared folder, but
        has access at some point in the subtree."

# --

route get_folder_metadata_2(InternalGetMetadataArgs, InternalSharedFolderMetadata, SharedFolderAccessError)
    "Returns internal shared folder metadata by its folder ID."

    attrs
        owner = "sfi"

struct InternalGetMetadataArgs
    shared_folder_id common.SharedFolderId
        "The ID for the shared folder."
    actions List(InternalFolderAction)?
        "Folder actions to query."

    example default
        shared_folder_id = "84528192421"
        actions = []

union InternalFolderAction extends FolderAction
    "Internal-only actions that may be taken on a shared folder."

    upgrade_to_team_folder
        "Upgrade the shared folder to a team folder."

    update_confidentiality
        "Update the confidentiality for a shared folder."

struct InternalFolderPermission
    "Whether the user is allowed to take the action on the shared folder."

    action InternalFolderAction
        "The action that the user may wish to take on the folder."
    allow Boolean
        "True if the user is allowed to take the action."
    reason PermissionDeniedReason?
        "The reason why the user is denied the permission. Not present if the action
        is allowed, or if no reason is available."

    example default
        action = edit_contents
        allow = false
        reason = user_not_same_team_as_owner

struct InternalSharedFolderMetadata extends SharedFolderMetadataBase
    "The metadata which includes internal information about the shared folder."

    is_confidential Boolean = false
        "Specifies that the folder is invite only."
    link_metadata SharedContentLinkMetadata?
        "The metadata of the shared content link to this shared folder. Absent if there is no
        link on the folder."
    name String
        "The name of the this shared folder."
    managed_by String?
        "A human-readable string telling the user how to manage the folder or who can manage
        it if they don't have permission."
    permissions List(InternalFolderPermission)?
        "Actions the current user may perform on the folder and its contents.
        The set of permissions corresponds to the InternalFolderActions in the request."
    policy FolderPolicy
        "Policies governing this shared folder."
    preview_url String
        "URL for displaying a web preview of the shared folder."
    shared_folder_id common.SharedFolderId
        "The ID of the shared folder."
    time_invited common.DropboxTimestamp
        "Timestamp indicating when the current user was invited to this shared folder."

    example default
        path_lower = "/dir"
        link_metadata = default
        name = "dir"
        shared_folder_id = "84528192421"
        permissions = []
        access_type = owner
        is_inside_team_folder = false
        is_team_folder = false
        policy = default
        time_invited = "2016-01-20T00:00:00Z"
        preview_url = "https://www.dropbox.com/scl/fo/fir9vjelf"
        is_confidential = false

# --

route internal_test_only/get_folder_shared_content_link(GetFolderSharedContentLinkArg, List(String), AddFolderMemberError)
    "Get the shared content link for the given folder and member information.

    Note 1: This is used ONLY for mobile integration test.
    Note 2: Because this is for internal test, we did not put more engineering efforts into this endpt to ensure its robustness,
        meaning that we only guarantee that for legal inputs, the generated URL will be equivalent (see Note III) to what is sent through the invitation email;
        for illegal inputs, the behavior of this endpt might be different from the add_folder_member endpt.
    Note 3: Due to the randomness introduced inside our encryption function,
        the r=? parameter in the url generated from this endpt will not be exactly the same
        as in the link in the email. However, we make sure that the decoded recipient information
        will be exactly the same between the two URLs.
    Note 4: The output URLs might not be in the same order as the input members. So if this order matters, you might want to pass in one member every time time.
    "

    attrs
        owner = "sharing"

struct GetFolderSharedContentLinkArg
    shared_folder_id common.SharedFolderId
        "The ID for the shared folder."
    members List(AddMember)
        "The target members that will end up in the 'r=' query param of the output urls."
    gen_email_link Boolean
        "Whether we generate a email tracking link (/l/*) or just the scl link /scl/fo/*"

    example default
        shared_folder_id = "84528192421"
        members = [default]
        gen_email_link = false

# --

route get_parent_folder_access(GetParentFolderAccessArg, MemberAccessLevelResult, ParentFolderAccessError)
    "Get the parent folders that a member has access to."

    attrs
        owner = "company-dropbox-team"

struct GetParentFolderAccessArg
    shared_folder_id common.SharedFolderId
        "The ID for the shared folder."
    member MemberSelector
        "The member of the shared folder to check for parent folder accesses. Only
        the :field:`MemberSelector.dropbox_id` may be set at this time."
    access_level AccessLevel?
        "If present, then only parent folders where the member has greater access will be
        returned. If not present, then returns all parent folder accesses."

    example default
        shared_folder_id = "84528192421"
        member = default
        access_level = viewer

union ParentFolderAccessError
    access_error SharedFolderAccessError
    member_error SharedFolderMemberError

# --

route share_folder_internal (ShareFolderInternalArg, ShareFolderInternalLaunch, ShareFolderError)
    "An internal version of :route:share_folder that can mark a folder Confidential."

    attrs
        owner = "company-dropbox-team"

struct ShareFolderInternalArg extends AlphaShareFolderArg
    confidentiality ConfidentialityArgs = not_confidential
        "Specifies the confidentiality settings on the folder"

    example default
        path = "/example/workspace"
        member_policy = team
        acl_update_policy = editors
        shared_link_policy = members

union_closed ShareFolderInternalLaunch extends async.LaunchResultBase
    complete InternalSharedFolderMetadata

    example default
        complete = default

# --

route set_confidentiality (SetConfidentialityArgs, ShareFolderInternalLaunch, SetConfidentialityError)
    "Set or unset an existing Shared Folder as Confidential.

    If a :field:`ShareFolderLaunch.async_job_id` is returned, you'll need to
    call :route:`check_share_job_status` until the action completes to get the
    metadata for the folder.
    "

    attrs
        owner = "company-dropbox-team"

struct SetConfidentialityArgs
    confidentiality ConfidentialityArgs = not_confidential
        "The Confidentiality settings for the folder"

    shared_folder_id common.SharedFolderId
        "The ID for the shared folder."

    example default
        shared_folder_id = "84528192421"
        confidentiality = not_confidential


union ConfidentialityArgs
    not_confidential
        "The Shared Folder is not Confidential and instead inherits its Members from the parent folder."

    confidential
        "The Shared Folder is marked Confidential and its Members can be restricted."

union SetConfidentialityError
    access_error SharedFolderAccessError
        "Unable to access shared folder."
    no_permission
        "The current user does not have permission to perform this action."

    example default
        no_permission = null

# --

union_closed ShareFolderInternalJobStatus extends async.PollResultBase
    complete InternalSharedFolderMetadata
        "The internal job has finished. The value is the internal metadata for the shared folder."
    failed ShareFolderError
        "Error occurred while performing the asynchronous job."

    example default
        complete = default

route check_share_internal_job_status (async.PollArg, ShareFolderInternalJobStatus, async.PollError)
    "Check the status of tasks that are expected to return InternalSharedFolderMetadata"

    attrs
        owner = "company-dropbox-team"

# --

struct AlphaSharedFolderMembers
    "Shared folder user and group membership. Same as SharedFolderMembers, but has AlphaUserMembershipInfo instead."

    users List(AlphaUserMembershipInfo)
        "The list of user members of the shared folder."
    groups List(GroupMembershipInfo)
        "The list of group members of the shared folder."
    invitees List(InviteeMembershipInfo)
        "The list of invitees to the shared folder."
    cursor String?
        "Present if there are additional shared folder members that have not been returned yet. Pass
        the cursor into :route:`list_folder_members/continue` to list additional members."

    example default
        users = [default]
        groups = [default]
        invitees = [default]
        cursor = "ZtkX9_EHj3x7PMkVuFIhwKYXEpwpLwyxp9vMKomUhllil9q7eWiAu"

# --

route unshare_folder/batch(UnshareFoldersBatchArg, async.LaunchEmptyResult, UnshareFoldersBatchError)
    "Allows an user to unshare a list of folders. Used only for the Sharing Paywall experiment

    Apps must have full Dropbox access to use this endpoint."

    attrs
        owner = "sub-growth"

struct UnshareFoldersBatchArg
    shared_folder_ids List(common.SharedFolderId)
        "The IDs for the shared folders."
    leave_a_copy Boolean = false
        "If true, members of this shared folder will get a copy of the folders
        after it's unshared. Otherwise, they will be removed from their Dropbox.
        The current user, who is an owner, will always retain their copy."

    example default
        shared_folder_ids = ["84528192421", "59285924215", "49120283928"]
        leave_a_copy = false

union UnshareFoldersBatchError
    some_folders_not_unshared
        "Some folders are not correctly unshared"

# --

struct AlphaFolderPolicy
    "A set of policies governing membership and privileges for a shared
    folder."

    member_policy MemberPolicy?
        "Who can be a member of this shared folder, as set on the folder itself.
        The effective policy may differ from this value if the team-wide policy
        is more restrictive. Present only if the folder is owned by a team."
    resolved_member_policy MemberPolicy?
        "Who can be a member of this shared folder, taking into account both the
        folder and the team-wide policy. This value may differ from that of
        member_policy if the team-wide policy is more restrictive than the folder
        policy. Present only if the folder is owned by a team."
    acl_update_policy AclUpdatePolicy
        "Who can add and remove members from this shared folder."
    download_policy DownloadPolicy
    pass_policy PassPolicy
        "DEPRECATED: use viewer_info_policy instead"
    viewer_info_policy ViewerInfoPolicy
    shared_link_policy SharedLinkPolicy

    example default
        member_policy = anyone
        resolved_member_policy = team
        acl_update_policy = owner
        shared_link_policy = anyone
        download_policy = disallow
        pass_policy = enabled
        viewer_info_policy = enabled

union AlphaFolderAction extends FolderAction
    disable_pass
        "Whether the user has permission to disable the viewer list information on the folder."
    enable_pass
        "Whether the user has permission to enable viewer list information on the folder."
    remove_download_policy
        "Whether the user has permission to remove the download policy and allow downloads on the
        folder.

        NOTE: This policy is probably subject to removal sometime soon. Talk to davy@ before using
        it."
    set_download_policy
        "Whether the user has permission to set the download policy and disallow downloads on the
        folder."

struct AlphaFolderPermission
    "Whether the user is allowed to take the action on the shared folder."

    action AlphaFolderAction
        "The action that the user may wish to take on the folder."
    allow Boolean
        "True if the user is allowed to take the action."
    reason PermissionDeniedReason?
        "The reason why the user is denied the permission. Not present if the action
        is allowed, or if no reason is available."

    example default
        action = edit_contents
        allow = false
        reason = user_not_same_team_as_owner

struct AlphaSharedFolderMetadata extends SharedFolderMetadataBase
    "Extended version of SharedFolderMetadata with link metadata and extended folder policy"
    link_metadata SharedContentLinkMetadata?
    name String
        "The name of the this shared folder."
    permissions List(AlphaFolderPermission)?
        "Actions the current user may perform on the folder and its contents.
        The set of permissions corresponds to the FolderActions in the request."
    policy AlphaFolderPolicy
        "Policies governing this shared folder."
    preview_url String
        "URL for displaying a web preview of the shared folder."
    shared_folder_id common.SharedFolderId
        "The ID of the shared folder."
    time_invited common.DropboxTimestamp
        "Timestamp indicating when the current user was invited to this shared folder."

struct AlphaGetMetadataArgs
    shared_folder_id common.SharedFolderId
        "The ID for the shared folder."
    actions List(AlphaFolderAction)?
        "This is a list indicating whether the returned folder data will include a boolean value
         :field:`FolderPermission.allow` that describes whether the current user can perform the
         FolderAction on the folder."

    example default
        shared_folder_id = "84528192421"
        actions = []

route alpha/get_folder_metadata(AlphaGetMetadataArgs, AlphaSharedFolderMetadata, SharedFolderAccessError)
    "Returns shared folder metadata by its folder ID.

    Apps must have full Dropbox access to use this endpoint.

    The same as get_folder_metadata, but also includes link metadata
    "

    attrs
        api_group = "sharing"
        is_preview = true
        owner = "sfi"

struct AlphaUpdateFolderPolicyArg
    "If any of the policy's are unset, then they retain their current setting."

    shared_folder_id common.SharedFolderId
        "The ID for the shared folder."
    member_policy MemberPolicy?
        "Who can be a member of this shared folder. Only applicable if the
        current user is on a team."
    acl_update_policy AclUpdatePolicy?
        "Who can add and remove members of this shared folder."
    actions List(AlphaFolderAction)?
    download_policy DownloadPolicy?
    pass_policy PassPolicy?
    shared_link_policy SharedLinkPolicy?
    link_settings AlphaLinkSettings?

    example default
        shared_folder_id = "84528192421"
        member_policy = team
        acl_update_policy = owner
        shared_link_policy = members

route alpha/update_folder_policy(AlphaUpdateFolderPolicyArg, AlphaSharedFolderMetadata, UpdateFolderPolicyError)
    "Update the sharing policies for a shared folder.

    User must have :field:`AccessLevel.owner` access to the shared folder to update its policies."

    attrs
        owner = "sfi"
        is_preview = true

union_closed AlphaShareFolderLaunch extends async.LaunchResultBase
    complete AlphaSharedFolderMetadata

route alpha/share_folder(AlphaShareFolderArg, AlphaShareFolderLaunch, ShareFolderError)
    attrs
        is_preview = true

struct AlphaShareFolderArg
    path files.WritePath
        "The path to the folder to share. If it does not exist, then a new one
        is created."
    member_policy MemberPolicy?
        "Who can be a member of this shared folder. Only applicable if the
        current user is on a team."
    acl_update_policy AclUpdatePolicy?
        "Who can add and remove members of this shared folder."
    shared_link_policy SharedLinkPolicy?
        "The policy to apply to shared links created for content inside this
        shared folder.  The current user must be on a team to set this policy to
        :field:`SharedLinkPolicy.members` or
        :field:`SharedLinkPolicy.team`."
    force_async Boolean = false
        "Whether to force the share to happen asynchronously."
    actions List(AlphaFolderAction)?
    download_policy DownloadPolicy?
    link_settings AlphaLinkSettings?
    pass_policy PassPolicy?
    viewer_info_policy ViewerInfoPolicy?


# --


route alpha/list_folders(AlphaListFoldersArgs, AlphaListFoldersResult, Void)
    "Return the list of all shared folders the current user has access to.

    Apps must have full Dropbox access to use this endpoint."

    attrs
        owner = "sfi"
        is_preview = true

struct AlphaListFoldersResult
    "Result for :route:`list_folders` or :route:`list_mountable_folders`, depending on which
    endpoint was requested.

    Unmounted shared folders can be identified by the absence of
    :field:`AlphaSharedFolderMetadata.path_lower`."

    entries List(AlphaSharedFolderMetadata)
        "List of all shared folders the authenticated user has access to."
    cursor String?
        "Present if there are additional shared folders that have not been returned yet. Pass the
        cursor into the corresponding continue endpoint (either :route:`alpha/list_folders/continue`
        or :route:`alpha/list_mountable_folders/continue`) to list additional folders."

struct AlphaListFoldersArgs
    limit UInt32(min_value=1, max_value=1000) = 1000
        "The maximum number of results to return per request."
    actions List(AlphaFolderAction)?
        "This is a list indicating whether each returned folder data entry will
        include a boolean field :field:`AlphaFolderPermission.allow` that describes
        whether the current user can perform the `AlphaFolderAction` on the folder."

    example default
        limit = 100
        actions = []


# --


route alpha/list_folders/continue(ListFoldersContinueArg, AlphaListFoldersResult, ListFoldersContinueError)
    "Once a cursor has been retrieved from :route:`list_folders`, use this to paginate through all
    shared folders. The cursor must come from a previous call to :route:`list_folders` or
    :route:`list_folders/continue`.

    Apps must have full Dropbox access to use this endpoint."

    attrs
        owner = "sfi"
        is_preview = true


# --


route alpha/list_mountable_folders(AlphaListFoldersArgs, AlphaListFoldersResult, Void)
    "Return the list of all shared folders the current user can mount or unmount.

    Apps must have full Dropbox access to use this endpoint."

    attrs
        owner = "sfi"
        is_preview = true


# --


route alpha/list_mountable_folders/continue(ListFoldersContinueArg, AlphaListFoldersResult, ListFoldersContinueError)
    "Once a cursor has been retrieved from :route:`list_mountable_folders`, use this to paginate through all
    mountable shared folders. The cursor must come from a previous call to :route:`list_mountable_folders` or
    :route:`list_mountable_folders/continue`.

    Apps must have full Dropbox access to use this endpoint."

    attrs
        owner = "sfi"
        is_preview = true
